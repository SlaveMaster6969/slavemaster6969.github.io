    <script>
        // --- GLOBAL THREE.JS AND GAME STATE VARIABLES ---
        
        let scene, camera, renderer;
        let player, playerVelocity = new THREE.Vector3();
        let spawnedBrainrots = [];
        
        let adminBrainrotMeshes = []; 
        
        let keys = { w: false, a: false, s: false, d: false, ' ': false, r: false }; // Added 'r'
        
        // Cube Camera variables for dynamic reflections
        let cubeCamera, cubeRenderTarget;
        let reflectiveGlassMaterial;

        // Game State Variables - CORE
        let money = 30; 
        let incomePerSecond = 0;
        let collection = [];
        let currentRotIndex = 0; 
        let stealSuccessChance = 0.6; 
        let purchasedUpgrades = {}; 
        
        // Game State Variables - PRESTIGE (NEW)
        let rebirthShards = 0;
        let incomeMultiplier = 1.0;
        const SHARD_INCOME_BOOST = 0.1; // 10% boost per shard
        const REBIRTH_COST = 1000000;

        // Physics and Movement State
        let isOnGround = false;
        const playerHalfHeight = 2.5; 
        
        // UI State Variables
        let isBaseVisible = false;
        let isControlsVisible = false;
        let isHudVisible = true; 
        let isUpgradesVisible = false; 
        let isSecretMenuVisible = false; 
        let isDeleteMenuVisible = false; 
        let isRebirthVisible = false; // NEW
        let isRenameMode = false; 
        let canToggleBase = true;
        let canToggleControls = true;
        let canToggleHud = true;
        let canToggleUpgrades = true; 
        let canToggleDelete = true; 
        let canToggleRebirth = true; // NEW
        
        let currentModRotIndex = -1; 

        // Secret Code Buffer and Data
        let codeBuffer = "";
        const secretCode = "codes";
        const RESET_CODE = "delete"; // NEW RESET CODE
        const CODES = {
            "new user": { type: "money", amount: 20, used: false },
        };
        
        // Texture URLs 
        const GRASS_URL = 'https://i.ibb.co/Tx3Rmgdj/grass.png';
        const ASPHALT_URL = 'https://i.ibb.co/QFg1LJpK/asphalt.png';
        const SKY_URL = 'https://i.ibb.co/xttD6kjB/sky.png';
        const BRICK_WALL_URL = 'https://i.ibb.co/pN2SxfR/images-3.jpg';
        const METAL_PANEL_URL = 'https://i.ibb.co/99j4mt5z/images-4.jpg';

        
        // Game Constants 
        const BRAINROT_DATA = [
            { name: "Tralalero", cost: 15, income: 0.1, rarity: "COMMON", color: 0x3498db },
            { name: "Cappuccino", cost: 75, income: 0.4, rarity: "COMMON", color: 0x7f8c8d },
            { name: "Medusa", cost: 300, income: 1.5, rarity: "RARE", color: 0x27ae60 },
            { name: "Spaghetti Tualetti", cost: 1500, income: 5.0, rarity: "SECRET", color: 0x9b59b6 }
        ];
        
        const UPGRADES_DATA = [
            { id: 'income_boost_1', name: "Quantum Processor", description: "Permanent +1.0 income/s.", cost: 500, type: "income_boost", value: 1.0 },
            { id: 'defense_1', name: "Encrypted Network", description: "Steal success chance increased by 5% (to max 95%).", cost: 1000, type: "steal_defense", value: 0.05 },
            { id: 'income_boost_2', name: "Hyper-Monetization", description: "Permanent +5.0 income/s.", cost: 3000, type: "income_boost", value: 5.0 },
            { id: 'defense_2', name: "Black Market Firewall", description: "Steal success chance increased by 10% (to max 95%).", cost: 5000, type: "steal_defense", value: 0.10 }
        ];


        const STEAL_COST = 75;
        const STEAL_PENALTY = 150; 
        
        // Physics and Movement State
        const moveSpeed = 10;
        const GRAVITY = -25; 
        const JUMP_FORCE = 10; 

        // Building Dimensions Constants 
        const TOWER_SIZE = 10;
        const TOWER_HEIGHT = 90; 
        const BRICK_COLOR = 0x9e5c5c; 
        const METAL_COLOR = 0xeeeeee; 

        // Global Texture Loader 
        const textureLoader = new THREE.TextureLoader();
        
        function initializeGameData() {
            UPGRADES_DATA.forEach(u => purchasedUpgrades[u.id] = false);
            // Attempt to load from cookies before initializing defaults
            loadGame(); 
        }

        // --- COOKIE FUNCTIONS (Persistence) ---

        const COOKIE_NAME = 'brainrotTycoonSave';

        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i=0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function saveGame() {
            const gameState = {
                money: money,
                incomePerSecond: incomePerSecond,
                collection: collection,
                purchasedUpgrades: purchasedUpgrades,
                stealSuccessChance: stealSuccessChance,
                rebirthShards: rebirthShards,        // NEW
                incomeMultiplier: incomeMultiplier,  // NEW
            };
            try {
                const jsonState = JSON.stringify(gameState);
                setCookie(COOKIE_NAME, jsonState, 365); // Save for 1 year
                // console.log("Game Saved.");
            } catch (e) {
                console.error("Error saving game:", e);
            }
        }

        function loadGame() {
            const savedState = getCookie(COOKIE_NAME);
            if (savedState) {
                try {
                    const gameState = JSON.parse(savedState);

                    money = gameState.money || 30;
                    // Income per second will be recalculated from collection and multiplier in a moment
                    // incomePerSecond = gameState.incomePerSecond || 0; 
                    collection = gameState.collection || [];
                    purchasedUpgrades = gameState.purchasedUpgrades || {};
                    stealSuccessChance = gameState.stealSuccessChance || 0.6;
                    
                    // Load Prestige State (Use || defaults for backward compatibility)
                    rebirthShards = gameState.rebirthShards || 0;
                    incomeMultiplier = gameState.incomeMultiplier || 1.0; 

                    // Recalculate true income per second based on the loaded collection and multiplier
                    recalculateIncome();
                    
                    refresh3DBrainrotCollection();
                    updateHUD();
                    updateCollectionList();
                    // console.log("Game Loaded.");
                } catch (e) {
                    console.error("Error loading game, starting new game:", e);
                    // Fallback to default state if load fails
                    money = 30;
                    collection = [];
                    purchasedUpgrades = {};
                    incomePerSecond = 0;
                }
            }
        }

        function resetGame(fullReset) {
            // fullReset = true for delete code (removes prestige)
            // fullReset = false for rebirth (keeps prestige)

            money = 30;
            incomePerSecond = 0;
            collection = [];
            
            // Clear all purchased upgrades
            UPGRADES_DATA.forEach(u => purchasedUpgrades[u.id] = false);
            stealSuccessChance = 0.6;
            
            // Delete all current 3D brainrots
            refresh3DBrainrotCollection(); 
            
            if (fullReset) {
                rebirthShards = 0;
                incomeMultiplier = 1.0;
                // Delete the cookie entirely on full reset
                setCookie(COOKIE_NAME, '', -1); 
            }

            // Immediately save the new state
            saveGame();
            
            updateHUD();
            updateCollectionList();
            selectNewRotToBuy();
            showMessage(`Account Wiped. Starting Fresh.`, '#c0392b', 'result-message');
        }

        // Helper function to recalculate income, used on load and rebirth
        function recalculateIncome() {
            const baseIncome = collection.reduce((total, item) => total + item.income, 0);
            
            // Add fixed income boosts from upgrades
            let upgradeBoost = 0;
            UPGRADES_DATA.filter(u => u.type === 'income_boost' && purchasedUpgrades[u.id]).forEach(u => {
                upgradeBoost += u.value;
            });

            // Calculate final income
            incomePerSecond = (baseIncome + upgradeBoost) * incomeMultiplier;
        }
        
        // --- CORE THREE.JS SETUP ---

        function init() {
            // Scene Setup... 
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0cfec); 
            
            // Apply SKY Texture to Background 
            const skyTexture = textureLoader.load(SKY_URL, 
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.mapping = THREE.EquirectangularReflectionMapping; 
                    scene.background = texture;
                },
                undefined,
                (err) => {
                    console.error('An error occurred loading the sky texture. Using solid color fallback.', err);
                }
            );

            // Fog color
            scene.fog = new THREE.Fog(0x87ceeb, 100, 300);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);
            
            // CubeCamera setup
            cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, { 
                format: THREE.RGBFormat, 
                generateMipmaps: true, 
                minFilter: THREE.LinearMipmapLinearFilter 
            });
            cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);
            scene.add(cubeCamera);


            // Lighting 
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
            scene.add(ambientLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0xadd8e6, 0x006400, 1.0); 
            scene.add(hemisphereLight);

            const sunLight = new THREE.DirectionalLight(0xffddaa, 3.0); 
            sunLight.position.set(100, 150, 50); 
            sunLight.castShadow = true;
            
            sunLight.shadow.mapSize.width = 2048; 
            sunLight.shadow.mapSize.height = 2048; 
            
            const d = 150; 
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            sunLight.shadow.camera.far = 400; 
            
            scene.add(sunLight);
            
            // Player 
            const playerGeometry = new THREE.BoxGeometry(1.5, 5, 1.5);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x9999ff, metalness: 0.1, roughness: 0.8 }); 
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(10, playerHalfHeight, 10); 
            player.castShadow = true;
            scene.add(player);

            // Camera follow
            player.add(camera);
            camera.position.set(0, 2.2, 0); 
            camera.rotation.x = -0.15; 

            createWorld();
            setupControls();
            
            // Initial setup
            initializeGameData(); // Loads or initializes, and calls recalculateIncome and updateHUD
            selectNewRotToBuy();
            refreshHudVisibility(); 

            // Handle Initial Popup
            const popup = document.getElementById('initial-popup');
            popup.style.opacity = 1; 
            setTimeout(() => {
                popup.style.opacity = 0; 
                setTimeout(() => {
                    popup.style.display = 'none'; 
                }, 1000); 
            }, 3000); 

            // Start the loops
            animate();
            setInterval(gameLoop, 1000);
            setInterval(spawnRandomBrainrot, 5000);
            setInterval(saveGame, 10000); // Auto-save every 10 seconds
        }

        // --- WORLD CREATION ---

        function createWorld() {
            let groundMaterial;
            
            const FALLBACK_COLOR = 0x2ecc71; 
            groundMaterial = new THREE.MeshStandardMaterial({ 
                color: FALLBACK_COLOR, 
                roughness: 0.9, 
                metalness: 0.0, 
                flatShading: false
            });

            const grassTexture = textureLoader.load(GRASS_URL, 
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(50, 50); 
                    groundMaterial.map = texture;
                    groundMaterial.needsUpdate = true;
                },
                undefined,
                (err) => {
                    console.error('An error occurred loading the grass texture. Using solid color fallback.', err);
                }
            );
            
            const brickTexture = textureLoader.load(BRICK_WALL_URL);
            brickTexture.wrapS = THREE.RepeatWrapping;
            brickTexture.wrapT = THREE.RepeatWrapping;
            brickTexture.repeat.set(4, 4); 

            const asphaltTexture = textureLoader.load(ASPHALT_URL);
            asphaltTexture.wrapS = THREE.RepeatWrapping;
            asphaltTexture.wrapT = THREE.RepeatWrapping;
            asphaltTexture.repeat.set(4, 4);

            const metalPanelTexture = textureLoader.load(METAL_PANEL_URL); 
            metalPanelTexture.wrapS = THREE.RepeatWrapping;
            metalPanelTexture.wrapT = THREE.RepeatWrapping;
            metalPanelTexture.repeat.set(2, 8); 

            // Materials... 
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xfaf8f6, roughness: 0.7, metalness: 0.1 });
            const marketMaterial = new THREE.MeshStandardMaterial({ map: asphaltTexture, roughness: 0.6, metalness: 0.2 });
            const brickWallMaterial = new THREE.MeshStandardMaterial({ map: brickTexture, roughness: 0.7, metalness: 0.1, color: BRICK_COLOR });
            const metalWallMaterial = new THREE.MeshStandardMaterial({ map: metalPanelTexture, roughness: 0.4, metalness: 0.9, color: METAL_COLOR });
            
            reflectiveGlassMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a2a3a, 
                metalness: 1.0,   
                roughness: 0.05,  
                transparent: true,
                opacity: 0.8,     
                envMap: cubeRenderTarget.texture, 
                envMapIntensity: 1.5 
            });


            // Building Helpers
            function createTower(x, z, yRotation) {
                const towerGeometry = new THREE.BoxGeometry(TOWER_SIZE, TOWER_HEIGHT, TOWER_SIZE);
                const tower = new THREE.Mesh(towerGeometry, metalWallMaterial); 
                tower.position.set(x, TOWER_SIZE / 2, z);
                tower.rotation.y = yRotation;
                tower.castShadow = true;
                scene.add(tower);
            }
            
            function createShop(x, z, yRotation) {
                const SHOP_HEIGHT = 30;
                const SHOP_SIZE = 10;
                const shopGeometry = new THREE.BoxGeometry(SHOP_SIZE, SHOP_HEIGHT, SHOP_SIZE);
                const shop = new THREE.Mesh(shopGeometry, metalWallMaterial);
                shop.position.set(x, SHOP_HEIGHT / 2, z);
                shop.rotation.y = yRotation;
                shop.castShadow = true;
                scene.add(shop);
            }
            
            function createHouse(x, z, yRotation) {
                const HOUSE_WALL_HEIGHT = 25; 
                const HOUSE_WIDTH = 20;
                const HOUSE_DEPTH = 16;
                const houseWallGeometry = new THREE.BoxGeometry(HOUSE_WIDTH, HOUSE_WALL_HEIGHT, HOUSE_DEPTH);
                const houseWalls = new THREE.Mesh(houseWallGeometry, brickWallMaterial);
                houseWalls.position.set(x, HOUSE_WALL_HEIGHT / 2, z);
                houseWalls.rotation.y = yRotation;
                houseWalls.castShadow = true;
                scene.add(houseWalls);
            }
            
            const buildingCreators = [createTower, createShop, createHouse];
            function createRandomBuilding(x, z, yRotation) {
                const creator = buildingCreators[Math.floor(Math.random() * buildingCreators.length)];
                creator(x, z, yRotation);
            }

            // Ground Plane
            const groundGeometry = new THREE.PlaneGeometry(550, 550);
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true; 
            scene.add(ground);

            // Player Base
            const baseGeometry = new THREE.BoxGeometry(10, 0.1, 10);
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, 0.05, 0); 
            base.receiveShadow = true;
            scene.add(base);

            // Central Market/Conveyor
            const marketGeometry = new THREE.BoxGeometry(8, 0.1, 8);
            const market = new THREE.Mesh(marketGeometry, marketMaterial);
            market.position.set(20, 0.05, 0);
            market.receiveShadow = true;
            scene.add(market);

            // Market Signpost
            const woodSignMaterial_local = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 }); 
            const signPole = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), woodSignMaterial_local);
            signPole.position.set(20, 2, -4);
            signPole.castShadow = true;
            scene.add(signPole);
            const signBoard = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 0.2), woodSignMaterial_local);
            signBoard.position.set(20, 4, -4);
            signBoard.castShadow = true;
            scene.add(signBoard);


            // Background City Border Generation
            const BORDER_DISTANCE = 250;
            const BUILDING_SPACING = 70;
            for (let x = -BORDER_DISTANCE; x <= BORDER_DISTANCE; x += BUILDING_SPACING) {
                createRandomBuilding(x, -BORDER_DISTANCE, 0); 
            }
            for (let x = -BORDER_DISTANCE; x <= BORDER_DISTANCE; x += BUILDING_SPACING) {
                createRandomBuilding(x, BORDER_DISTANCE, Math.PI); 
            }
            for (let z = -BORDER_DISTANCE + BUILDING_SPACING; z <= BORDER_DISTANCE - BUILDING_SPACING; z += BUILDING_SPACING) {
                createRandomBuilding(-BORDER_DISTANCE, z, Math.PI / 2); 
            }
            for (let z = -BORDER_DISTANCE + BUILDING_SPACING; z <= BORDER_DISTANCE - BUILDING_SPACING; z += BUILDING_SPACING) {
                createRandomBuilding(BORDER_DISTANCE, z, -Math.PI / 2); 
            }

        }

        // --- INPUT CONTROLS ---

        function showModal(title, message, onConfirm, showCancel = true) {
            const modal = document.getElementById('confirmation-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');

            modalTitle.textContent = title;
            modalMessage.innerHTML = message;
            
            // Reattach event listeners to prevent multiple calls
            const confirmClone = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(confirmClone, confirmBtn);
            
            const cancelClone = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(cancelClone, cancelBtn);
            
            const newConfirmBtn = document.getElementById('modal-confirm');
            const newCancelBtn = document.getElementById('modal-cancel');


            newConfirmBtn.onclick = () => {
                onConfirm();
                modal.style.display = 'none';
            };

            newCancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            newCancelBtn.style.display = showCancel ? 'inline-block' : 'none';
            modal.style.display = 'flex';
        }

        function showMessage(text, bgColor, elementId) {
            const messageDisplay = document.getElementById(elementId) || document.getElementById('result-message');
            messageDisplay.style.backgroundColor = bgColor;
            messageDisplay.style.color = 'white';
            messageDisplay.textContent = text;
            
            setTimeout(() => {
                messageDisplay.textContent = '';
                messageDisplay.style.backgroundColor = 'transparent';
            }, 3000);
        }

        function refreshHudVisibility() {
            const hud = document.getElementById('hud');
            const marketContent = document.getElementById('market-content');
            const baseSection = document.getElementById('base-section');
            const upgradesMenu = document.getElementById('upgrades-menu');
            const rebirthMenu = document.getElementById('rebirth-menu'); // NEW
            const secretMenu = document.getElementById('secret-menu');
            const modMenu = document.getElementById('income-mod-menu');
            const deleteMenu = document.getElementById('delete-menu'); 
            const modal = document.getElementById('confirmation-modal');

            // 1. Check for blocking modals (Admin/Delete/Rebirth)
            const isAnySecretMenuOpen = isSecretMenuVisible || modMenu.classList.contains('hidden') === false;
            
            if (isAnySecretMenuOpen || isDeleteMenuVisible || isRebirthVisible || modal.style.display === 'flex') {
                hud.classList.add('hidden');
                upgradesMenu.style.display = 'none';
                rebirthMenu.style.display = isRebirthVisible ? 'block' : 'none'; // NEW
                secretMenu.classList.toggle('hidden', !isSecretMenuVisible || modMenu.classList.contains('hidden') === false);
                modMenu.classList.toggle('hidden', currentModRotIndex === -1);
                deleteMenu.classList.toggle('hidden', !isDeleteMenuVisible);
                return;
            }

            // 2. If no blocking modals, manage HUD and Upgrades
            
            // Toggle Upgrades Menu
            upgradesMenu.style.display = isUpgradesVisible ? 'block' : 'none';
            if (isUpgradesVisible) {
                hud.classList.add('hidden');
                displayUpgrades();
            } else {
                // Toggle Main HUD (Market/Base)
                marketContent.style.display = isHudVisible ? 'block' : 'none';
                baseSection.style.display = isBaseVisible ? 'block' : 'none';
                
                if (isHudVisible || isBaseVisible) {
                    hud.classList.remove('hidden');
                } else {
                    hud.classList.add('hidden');
                }
            }
        }
        
        function toggleSecretMenu() {
            isSecretMenuVisible = !isSecretMenuVisible;
            const menu = document.getElementById('secret-menu');
            const modMenu = document.getElementById('income-mod-menu');

            if (!isSecretMenuVisible) {
                modMenu.classList.add('hidden');
                currentModRotIndex = -1;
                isRenameMode = false;
            }

            menu.classList.toggle('hidden', !isSecretMenuVisible);

            if (isSecretMenuVisible) {
                updateSecretCollectionList();
                document.getElementById('code-input').focus();
                
            } 
            refreshHudVisibility();
            codeBuffer = ""; 
        }

        function toggleDeleteMenu() {
            if (isSecretMenuVisible || isUpgradesVisible || currentModRotIndex !== -1 || isRebirthVisible) return;

            isDeleteMenuVisible = !isDeleteMenuVisible;
            const menu = document.getElementById('delete-menu');
            menu.classList.toggle('hidden', !isDeleteMenuVisible);
            
            if (isDeleteMenuVisible) {
                updateDeleteList();
            }
            refreshHudVisibility();
        }

        // NEW: Toggle Rebirth Menu
        function toggleRebirthMenu() {
            if (isSecretMenuVisible || isUpgradesVisible || isDeleteMenuVisible) return;

            isRebirthVisible = !isRebirthVisible;
            
            if (isRebirthVisible) {
                updateRebirthMenu();
            }

            refreshHudVisibility();
        }

        function toggleHudView() {
            if (isSecretMenuVisible || isUpgradesVisible || isDeleteMenuVisible || isRebirthVisible) return;
            isHudVisible = !isHudVisible;
            refreshHudVisibility();
        }

        function toggleBaseView() {
            if (isSecretMenuVisible || isUpgradesVisible || isDeleteMenuVisible || isRebirthVisible) return;
            isBaseVisible = !isBaseVisible;
            refreshHudVisibility();
        }
        
        function toggleUpgradesMenu() {
            if (isSecretMenuVisible || isDeleteMenuVisible || isRebirthVisible) return;
            isUpgradesVisible = !isUpgradesVisible;
            refreshHudVisibility();
        }

        function toggleControls() {
            isControlsVisible = !isControlsVisible;
            document.getElementById('controls-instructions').style.display = isControlsVisible ? 'block' : 'none';
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                
                // Secret Code Tracking 
                if (key.length === 1 && /[a-z0-9]/.test(key)) {
                    codeBuffer += key;
                    if (codeBuffer.length > secretCode.length) {
                        codeBuffer = codeBuffer.substring(codeBuffer.length - secretCode.length);
                    }
                    
                    if (codeBuffer === secretCode) {
                        toggleSecretMenu();
                        codeBuffer = ""; 
                        return; 
                    }
                } else if (key === 'escape') {
                    if (currentModRotIndex !== -1) {
                        closeIncomeModMenu();
                        return;
                    }
                    if (isSecretMenuVisible) {
                        toggleSecretMenu();
                        return;
                    }
                    if (isUpgradesVisible) { 
                        toggleUpgradesMenu();
                        return;
                    }
                    if (isDeleteMenuVisible) { 
                        toggleDeleteMenu();
                        return;
                    }
                    if (isRebirthVisible) { // Close Rebirth with ESC
                        toggleRebirthMenu();
                        return;
                    }
                    codeBuffer = ""; 
                } else {
                    // Check for R key before movement/toggle logic
                    if (key === 'r' && canToggleRebirth && !isSecretMenuVisible && !isUpgradesVisible && !isDeleteMenuVisible) {
                        toggleRebirthMenu();
                        canToggleRebirth = false;
                        setTimeout(() => canToggleRebirth = true, 200);
                        e.preventDefault(); // Stop 'r' from entering text field if one is focused
                    }

                    if (!['w', 'a', 's', 'd', 'q', 'e', 'c', 'f', '8', 'r', ' '].includes(key) && key.length > 1) {
                         codeBuffer = "";
                    }
                }

                if (isSecretMenuVisible || document.getElementById('income-mod-menu').classList.contains('hidden') === false || isDeleteMenuVisible || isRebirthVisible) {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                        e.preventDefault();
                    }
                    return;
                }
                
                if (keys.hasOwnProperty(key)) keys[key] = true;
                if (e.keyCode === 32) keys[' '] = true; 
                
                if (key === 'e' && canToggleBase) {
                    toggleBaseView();
                    canToggleBase = false;
                    setTimeout(() => canToggleBase = true, 200); 
                }
                
                if (key === 'c' && canToggleControls) {
                    toggleControls();
                    canToggleControls = false;
                    setTimeout(() => canToggleControls = true, 200); 
                }
                
                if (key === 'q' && canToggleHud) {
                    toggleHudView();
                    canToggleHud = false;
                    setTimeout(() => canToggleHud = true, 200); 
                }
                
                if (key === 'f' && canToggleUpgrades) {
                    toggleUpgradesMenu();
                    canToggleUpgrades = false;
                    setTimeout(() => canToggleUpgrades = true, 200); 
                }

                if (key === '8' && canToggleDelete) {
                    toggleDeleteMenu();
                    canToggleDelete = false;
                    setTimeout(() => canToggleDelete = true, 200); 
                }
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
                if (e.keyCode === 32) keys[' '] = false;
                if (key === 'q') keys['q'] = false;
            });

            // Mouse Look 
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const rotationSpeed = 0.005;
            const maxPitch = Math.PI / 4; 

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging || isSecretMenuVisible || isUpgradesVisible || isDeleteMenuVisible || isRebirthVisible) return; 
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y; 

                player.rotation.y -= deltaX * rotationSpeed;
                
                let newPitch = camera.rotation.x - deltaY * rotationSpeed; 
                newPitch = Math.max(-maxPitch, Math.min(maxPitch, newPitch));
                camera.rotation.x = newPitch;

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        // --- GAMEPLAY FUNCTIONS ---

        function updateHUD() {
            document.getElementById('money-display').textContent = money.toFixed(2);
            document.getElementById('income-display').textContent = (incomePerSecond).toFixed(2); // Displays actual income
            document.getElementById('rot-count').textContent = collection.length;
            
            // NEW Prestige Displays
            document.getElementById('shard-display').textContent = rebirthShards;
            document.getElementById('multiplier-display').textContent = incomeMultiplier.toFixed(2);
        }

        function updateCollectionList() {
            const list = document.getElementById('collection-list');
            list.innerHTML = '';
            collection.forEach(rot => {
                const p = document.createElement('p');
                
                let rarityText = rot.rarity;
                let pColor = '#' + new THREE.Color(rot.color).getHexString();
                let pClass = '';
                
                if (rot.isAdmin) {
                    rarityText = 'THE ADMIN GODS';
                    pClass = 'rainbow-text';
                    pColor = 'inherit';
                }
                
                // Show base income, not multiplied income here
                p.textContent = `[${rarityText}] ${rot.name} (+$${rot.income.toFixed(2)}/s)`;
                p.style.fontSize = '0.9rem';
                p.style.color = pColor; 
                if (pClass) p.classList.add(pClass);
                
                list.appendChild(p);
            });
        }
        
        function updateRebirthMenu() {
            document.getElementById('rebirth-cost-display').textContent = REBIRTH_COST.toLocaleString('en-US');
            document.getElementById('rebirth-money-display').textContent = money.toFixed(2);
            document.getElementById('rebirth-multiplier-display').textContent = incomeMultiplier.toFixed(2);

            const shardsToGain = Math.floor(money / REBIRTH_COST * 10);
            document.getElementById('shards-to-gain-display').textContent = shardsToGain;

            const button = document.getElementById('perform-rebirth-button');
            const statusMessage = document.getElementById('rebirth-status-message');

            if (money >= REBIRTH_COST) {
                button.disabled = false;
                statusMessage.textContent = `You are ready to ascend! Gain ${shardsToGain} Brainrot Shards.`;
                statusMessage.className = 'text-lg mb-6 font-bold text-yellow-300';
            } else {
                button.disabled = true;
                const needed = (REBIRTH_COST - money).toFixed(2);
                statusMessage.textContent = `You need $${needed} more cash to perform Rebirth.`;
                statusMessage.className = 'text-lg mb-6 text-cyan-300';
            }
        }
        
        function handleRebirthAttempt() {
            if (money >= REBIRTH_COST) {
                const shardsToGain = Math.floor(money / REBIRTH_COST * 10);
                const newMultiplier = (1 + (rebirthShards + shardsToGain) * SHARD_INCOME_BOOST).toFixed(2);
                
                showModal(
                    "ASCENSION CONFIRMATION",
                    `Are you sure you want to Rebirth? You will lose everything (except Upgrades, Shards and Multiplier) but gain **${shardsToGain} Brainrot Shards**.<br><br>New Multiplier: **x${newMultiplier}**`,
                    () => { performRebirth(shardsToGain); }
                );
            } else {
                showMessage("INSUFFICIENT FUNDS for Rebirth!", '#e74c3c', 'result-message');
            }
        }

        function performRebirth(shardsGained) {
            rebirthShards += shardsGained;
            incomeMultiplier = 1.0 + (rebirthShards * SHARD_INCOME_BOOST);
            
            // Soft reset: keeps upgrades, keeps prestige
            resetGame(false); 
            
            showMessage(`✨ REBIRTH SUCCESS! Gained ${shardsGained} Shards! Multiplier is now x${incomeMultiplier.toFixed(2)}!`, '#34e7f9', 'result-message');
            toggleRebirthMenu();
            saveGame();
        }

        function displayUpgrades() {
            const list = document.getElementById('upgrades-list');
            list.innerHTML = '';
            
            UPGRADES_DATA.forEach(upgrade => {
                const isPurchased = purchasedUpgrades[upgrade.id];
                
                const div = document.createElement('div');
                div.className = 'p-3 my-2 border border-yellow-500 rounded-xl flex flex-col sm:flex-row justify-between items-start sm:items-center bg-purple-800 shadow-xl transition duration-300 hover:scale-[1.02]';
                
                let buttonHtml = '';
                if (isPurchased) {
                    buttonHtml = '<span class="text-green-400 font-bold ml-4 text-sm mt-2 sm:mt-0">✅ OWNED</span>';
                } else {
                    const isDisabled = money < upgrade.cost;
                    buttonHtml = `<button 
                        onclick="buyUpgrade('${upgrade.id}')" 
                        class="ml-0 sm:ml-4 mt-2 sm:mt-0 bg-yellow-500 text-gray-900 font-bold px-4 py-2 rounded-lg hover:bg-yellow-400 transition disabled:bg-gray-500 disabled:shadow-none text-sm shadow-md" 
                        ${isDisabled ? 'disabled' : ''}>
                        Buy ($${upgrade.cost.toFixed(2)})
                    </button>`;
                }

                div.innerHTML = `
                    <div class="flex-grow">
                        <p class="font-bold text-lg text-white">${upgrade.name}</p>
                        <p class="text-sm text-fuchsia-300">${upgrade.description}</p>
                    </div>
                    ${buttonHtml}
                `;
                list.appendChild(div);
            });
        }

        function buyUpgrade(id) {
            const upgrade = UPGRADES_DATA.find(u => u.id === id);
            const messageDisplay = document.getElementById('result-message'); 
            
            if (!upgrade || purchasedUpgrades[id]) return;

            if (money >= upgrade.cost) {
                money -= upgrade.cost;
                purchasedUpgrades[id] = true;

                if (upgrade.type === "income_boost") {
                    recalculateIncome(); // Recalculate based on new boost * multiplier
                    showMessage(`✅ PURCHASED ${upgrade.name}! Income boosted.`, '#9b59b6', 'result-message');
                } else if (upgrade.type === "steal_defense") {
                    stealSuccessChance = Math.min(0.95, stealSuccessChance + upgrade.value);
                    showMessage(`✅ PURCHASED ${upgrade.name}! Steal success chance is now ${Math.round(stealSuccessChance * 100)}%.`, '#9b59b6', 'result-message');
                }
                
                updateHUD();
                displayUpgrades(); 
                toggleUpgradesMenu(); 
                saveGame();

            } else {
                const errorPopup = document.createElement('div');
                errorPopup.id = 'temp-error';
                errorPopup.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-600 text-white p-4 rounded-lg font-bold z-[5000] shadow-2xl';
                errorPopup.textContent = `INSUFFICIENT FUNDS! Need $${(upgrade.cost - money).toFixed(2)} more.`;
                document.body.appendChild(errorPopup);
                
                setTimeout(() => {
                    errorPopup.remove();
                }, 2000);
            }
        }
        
        function updateSecretCollectionList() {
            const list = document.getElementById('secret-collection-list');
            list.innerHTML = '';

            if (collection.length === 0) {
                list.textContent = "You have no Brainrots yet! Go buy or steal some.";
                list.className = 'text-center text-gray-400 p-4';
                return;
            }
            list.className = 'max-h-60 overflow-y-auto space-y-2'; 

            collection.forEach((rot, index) => {
                const item = document.createElement('div');
                item.id = `rot-item-${index}`; 
                item.className = 'flex justify-between items-center p-2 bg-gray-700 rounded-lg shadow-md';

                const block = document.createElement('div');
                block.style.width = '15px';
                block.style.height = '15px';
                const blockColor = rot.isAdmin ? '#f1c40f' : '#' + new THREE.Color(rot.color).getHexString();
                block.style.backgroundColor = blockColor;
                block.className = 'rounded-sm shadow-lg border border-gray-400';
                
                
                let rarityText = rot.rarity;
                let infoColor = '#' + new THREE.Color(rot.color).getHexString();
                let infoClass = 'font-mono text-sm flex-grow ml-3 overflow-hidden whitespace-nowrap overflow-ellipsis';
                
                if (rot.isAdmin) {
                    rarityText = 'THE ADMIN GODS';
                    infoClass += ' rainbow-text';
                    infoColor = 'inherit';
                }

                const info = document.createElement('span');
                info.textContent = `[${rarityText}] ${rot.name} (+$${rot.income.toFixed(2)}/s)`;
                info.style.color = infoColor;
                if (rot.isAdmin) info.classList.add('rainbow-text');
                info.className = infoClass;


                item.appendChild(block);
                item.appendChild(info);

                if (isRenameMode) {
                    const renameBtn = document.createElement('button');
                    renameBtn.textContent = 'RENAME';
                    renameBtn.className = 'ml-3 bg-indigo-600 text-white text-xs px-2 py-1 rounded hover:bg-indigo-700 transition';
                    renameBtn.onclick = () => { handleRenameClick(index); };
                    item.appendChild(renameBtn);
                }

                list.appendChild(item);
            });
        }

        function handleRenameClick(index) {
            const listItem = document.getElementById(`rot-item-${index}`);
            const rot = collection[index];

            listItem.innerHTML = ''; 

            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-center space-x-2 w-full';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = rot.name;
            input.placeholder = 'New Name...';
            input.className = 'p-2 bg-gray-600 text-white rounded flex-grow focus:ring-yellow-500 focus:border-yellow-500 border-transparent text-sm';

            const saveButton = document.createElement('button');
            saveButton.textContent = 'SAVE';
            saveButton.className = 'bg-green-600 text-white p-2 rounded text-sm hover:bg-green-700 transition';
            saveButton.onclick = () => {
                saveNewName(index, input.value);
            };

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'X';
            cancelButton.className = 'bg-red-600 text-white p-2 rounded text-sm hover:bg-red-700 transition';
            cancelButton.onclick = () => {
                isRenameMode = false; 
                updateSecretCollectionList(); 
            };

            wrapper.appendChild(input);
            wrapper.appendChild(saveButton);
            wrapper.appendChild(cancelButton);
            listItem.appendChild(wrapper);
            input.focus();
        }

        function saveNewName(index, newName) {
            const trimmedName = newName.trim();
            
            if (collection[index] && trimmedName) {
                const originalRarity = collection[index].rarity;

                if (originalRarity === 'RARE' && collection[index].name === 'Medusa' && trimmedName.toLowerCase() === 'simonsays') {
                    collection[index].name = trimmedName; 
                    collection[index].isAdmin = true; 
                    refresh3DBrainrotCollection(); 
                    openIncomeModMenu(index);
                    saveGame();
                    return; 
                }
                
                collection[index].name = trimmedName; 
                collection[index].isAdmin = false; 
                
                showMessage(`Name changed to "${collection[index].name}"!`, '#2ecc71', 'code-result-message');
            }
            
            isRenameMode = false; 
            updateSecretCollectionList();
            updateCollectionList(); 
            saveGame();
        }
        
        // --- SECRET MENU 2 & DELETION FUNCTIONS ---
        
        function updateDeleteList() {
            const list = document.getElementById('delete-list');
            list.innerHTML = '';
            
            if (collection.length === 0) {
                list.innerHTML = '<p class="text-center text-red-300 font-bold">You have no Brainrots to delete!</p>';
                document.getElementById('delete-menu').querySelector('button.bg-red-600').disabled = true;
                return;
            }
            
            document.getElementById('delete-menu').querySelector('button.bg-red-600').disabled = false;
            
            collection.forEach((rot, index) => {
                const item = document.createElement('label');
                item.className = 'flex items-center p-3 bg-red-900/50 rounded-lg cursor-pointer transition hover:bg-red-800/70';
                
                let rarityText = rot.rarity;
                let pClass = '';
                if (rot.isAdmin) {
                    rarityText = 'THE ADMIN GODS';
                    pClass = 'rainbow-text';
                }
                
                item.innerHTML = `
                    <input type="checkbox" data-index="${index}" class="form-checkbox h-5 w-5 text-red-500 rounded border-gray-300 focus:ring-red-500">
                    <span class="ml-3 text-white font-medium">
                        <span class="${pClass}">[${rarityText}]</span> 
                        ${rot.name} 
                        (<span class="text-red-400">Income: -$${rot.income.toFixed(2)}/s</span>)
                    </span>
                `;
                list.appendChild(item);
            });
        }
        
        function confirmDeletion() {
            const checkboxes = document.querySelectorAll('#delete-list input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                showMessage("No Brainrots selected for deletion.", '#f39c12', 'delete-message');
                return;
            }

            const indicesToDelete = Array.from(checkboxes)
                .map(cb => parseInt(cb.dataset.index, 10))
                .sort((a, b) => b - a); 

            let deletedIncome = 0;
            
            indicesToDelete.forEach(index => {
                const deletedRot = collection.splice(index, 1)[0]; 
                deletedIncome += deletedRot.income;
            });

            recalculateIncome();

            refresh3DBrainrotCollection();
            updateHUD();
            updateCollectionList();
            saveGame();
            
            showMessage(`Successfully DELETED ${indicesToDelete.length} Brainrot(s). Income reduced by $${deletedIncome.toFixed(2)}/s.`, '#c0392b', 'delete-message');
            
            setTimeout(() => {
                toggleDeleteMenu(); 
            }, 2000);
        }

        function openIncomeModMenu(index) {
            isSecretMenuVisible = true; 
            currentModRotIndex = index;
            isRenameMode = false;

            const rot = collection[index];
            
            document.getElementById('secret-menu').classList.add('hidden');
            
            const modMenu = document.getElementById('income-mod-menu');
            modMenu.classList.remove('hidden');
            
            const modRotName = document.getElementById('mod-rot-name');
            if (rot.isAdmin) {
                modRotName.innerHTML = `Editing: ${rot.name} (Rarity: <span class="rainbow-text">THE ADMIN GODS</span>)`;
            } else {
                modRotName.textContent = `Editing: ${rot.name} (Rarity: ${rot.rarity})`;
            }

            document.getElementById('current-income-display').textContent = rot.income.toFixed(2);
            document.getElementById('new-income-input').value = rot.income.toFixed(2);
        }

        function closeIncomeModMenu() {
            currentModRotIndex = -1;
            document.getElementById('income-mod-menu').classList.add('hidden');
            document.getElementById('secret-menu').classList.remove('hidden');
            updateSecretCollectionList(); 
        }
        
        function applyIncomeChange() {
            if (currentModRotIndex === -1) {
                console.error("No Brainrot selected for income modification.");
                return;
            }

            const inputElement = document.getElementById('new-income-input');
            let newIncome = parseFloat(inputElement.value);
            const rot = collection[currentModRotIndex];
            
            if (isNaN(newIncome) || newIncome < 0) {
                 showMessage('Invalid income value. Must be a positive number.', '#e74c3c', 'code-result-message');
                 return;
            }
            
            rot.income = newIncome;
            recalculateIncome();
            
            updateHUD();
            updateCollectionList();
            saveGame();
            
            showMessage(`SUCCESS! ${rot.name}'s income is now $${newIncome.toFixed(2)}/s.`, '#fuchsia-500', 'code-result-message');
            
            setTimeout(() => {
                closeIncomeModMenu();
            }, 1500);
        }
        
        // --- END SECRET MENU 2 & DELETION FUNCTIONS ---


        function redeemCode() {
            const inputField = document.getElementById('code-input');
            const code = inputField.value.trim().toLowerCase();
            
            inputField.value = ''; 

            if (code === RESET_CODE) { // New reset code logic
                showModal(
                    "BRAINROT MEMORY WIPE",
                    "WARNING: This will delete ALL progress, including prestige Shards. Are you sure you want to proceed?",
                    () => { 
                        toggleSecretMenu(); // Close secret menu
                        resetGame(true); 
                    },
                    true
                );
                return;
            }

            if (code === "changename") {
                isRenameMode = true;
                updateSecretCollectionList();
                showMessage(`RENAME MODE ACTIVATED! Click 'RENAME' next to a Brainrot.`, '#3498db', 'code-result-message');
                return;
            }

            if (CODES[code]) {
                if (!CODES[code].used) {
                    if (CODES[code].type === "money") {
                        money += CODES[code].amount;
                        CODES[code].used = true; 
                        updateHUD();
                        saveGame();
                        showMessage(`CODE ACCEPTED: Added $${CODES[code].amount.toFixed(2)} to your balance!`, '#2ecc71', 'code-result-message');
                    }
                } else {
                    showMessage(`CODE ALREADY USED.`, '#f39c12', 'code-result-message');
                }
            } else {
                showMessage(`INVALID CODE: ${code.toUpperCase()}`, '#e74c3c', 'code-result-message');
            }
        }
        
        function refresh3DBrainrotCollection() {
            scene.traverse(child => {
                if (child.userData.isBrainrot) {
                    scene.remove(child);
                }
            });
            adminBrainrotMeshes = [];

            collection.forEach(rotData => {
                spawnBrainrot3D(rotData);
            });
        }
        
        function spawnBrainrot3D(rotData) {
            const itemIndex = collection.findIndex(r => r === rotData); 
            
            const itemsPerLayer = 9;
            const slotIndex = itemIndex % itemsPerLayer; 
            const layer = Math.floor(itemIndex / itemsPerLayer); 
            
            const gridSpacing = 1.5;
            
            const gridX = (slotIndex % 3) * gridSpacing - gridSpacing; 
            const gridZ = Math.floor(slotIndex / 3) * gridSpacing - gridSpacing; 
            
            const y = layer * 1.0 + 0.5; 

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            let material;
            
            if (rotData.isAdmin) {
                material = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff, 
                    specular: 0xffffff, 
                    shininess: 100,      
                    flatShading: true
                });
            } else {
                material = new THREE.MeshPhongMaterial({ 
                    color: rotData.color, 
                    specular: 0xffffff, 
                    shininess: 100,      
                    flatShading: true
                });
            }

            const brainrotMesh = new THREE.Mesh(geometry, material);
            
            brainrotMesh.position.set(gridX, y + 0.1, gridZ); 
            
            brainrotMesh.castShadow = true;
            brainrotMesh.userData.isBrainrot = true; 
            scene.add(brainrotMesh);
            
            if (rotData.isAdmin) {
                adminBrainrotMeshes.push(brainrotMesh);
            }
        }

        function spawnRandomBrainrot() {
            const randomRotIndex = Math.floor(Math.random() * BRAINROT_DATA.length);
            const rotData = BRAINROT_DATA[randomRotIndex];

            let x, z;
            do {
                x = Math.random() * 80 - 40; 
                z = Math.random() * 80 - 40; 
            } while (
                (x > -15 && x < 15 && z > -15 && z < 15) || 
                (x > 5 && x < 35 && z > -15 && z < 15)
            );

            const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5); 
            const material = new THREE.MeshPhongMaterial({ 
                color: rotData.color, 
                specular: 0xffffff, 
                shininess: 150 
            });
            const brainrotMesh = new THREE.Mesh(geometry, material);
            
            brainrotMesh.position.set(x, 0.4, z);
            brainrotMesh.castShadow = true;
            brainrotMesh.userData.rotData = rotData; 

            scene.add(brainrotMesh);
            spawnedBrainrots.push(brainrotMesh);
        }

        function checkBrainrotPickup() {
            const pickupDistance = 2.5; 
            
            const playerXZ = new THREE.Vector2(player.position.x, player.position.z);
            const rotXZ = new THREE.Vector2();

            for (let i = spawnedBrainrots.length - 1; i >= 0; i--) {
                const rotMesh = spawnedBrainrots[i];
                
                rotXZ.set(rotMesh.position.x, rotMesh.position.z);
                
                const distanceXZ = playerXZ.distanceTo(rotXZ);
                
                if (distanceXZ < pickupDistance) {
                    const rotData = rotMesh.userData.rotData;
                    
                    const newRot = Object.assign({}, rotData, { isAdmin: false });
                    collection.push(newRot); 
                    recalculateIncome();
                    
                    spawnBrainrot3D(collection[collection.length - 1]); 
                    
                    scene.remove(rotMesh);
                    spawnedBrainrots.splice(i, 1);
                    
                    updateHUD();
                    updateCollectionList();
                    saveGame();
                    
                    showMessage(`⭐ FOUND a [${rotData.rarity}] ${rotData.name}!`, '#f1c40f', 'result-message');

                    return; 
                }
            }
        }
        
        function buyCurrentRot() {
            const rotToBuy = BRAINROT_DATA[currentRotIndex];

            if (money >= rotToBuy.cost) {
                money -= rotToBuy.cost;
                
                const newRot = Object.assign({}, rotToBuy, { isAdmin: false });
                collection.push(newRot); 
                recalculateIncome();
                
                spawnBrainrot3D(newRot);

                showMessage(`PURCHASE SUCCESS! Gained ${rotToBuy.name}.`, '#2ecc71', 'result-message');
                
                selectNewRotToBuy(); 
                updateHUD();
                updateCollectionList();
                saveGame();
            } else {
                showMessage(`INSUFFICIENT FUNDS! Need $${(rotToBuy.cost - money).toFixed(2)} more.`, '#e74c3c', 'result-message');
            }
        }

        function attemptSteal() {
            
            if (money < STEAL_COST) {
                showMessage(`❌ RAID FAILED before launch: Need $${STEAL_COST.toFixed(2)} for gear!`, '#e74c3c', 'result-message');
                return;
            }
            
            money -= STEAL_COST;
            
            if (Math.random() < stealSuccessChance) {
                const randomRotIndex = Math.floor(Math.random() * BRAINROT_DATA.length);
                const stolenRot = BRAINROT_DATA[randomRotIndex];
                
                const newRot = Object.assign({}, stolenRot, { isAdmin: false });
                collection.push(newRot); 
                recalculateIncome();

                spawnBrainrot3D(newRot);

                showMessage(`✅ RAID SUCCESS! Stole a [${stolenRot.rarity}] ${stolenRot.name}!`, '#3498db', 'result-message');

            } else {
                
                money = Math.max(0, money - STEAL_PENALTY);
                
                showMessage(`🚨 RAID FAILED! You got hammered! Lost $${STEAL_PENALTY.toFixed(2)} in fines.`, '#e74c3c', 'result-message');
            }
            
            updateHUD();
            updateCollectionList();
            saveGame();
        }
        
        function selectNewRotToBuy() {
            currentRotIndex = Math.floor(Math.random() * BRAINROT_DATA.length);
            const rot = BRAINROT_DATA[currentRotIndex];
            
            document.getElementById('current-rot-info').innerHTML = 
                `<strong>${rot.name}</strong> (${rot.rarity}) | Cost: $${rot.cost.toFixed(2)} | Income: ${rot.income.toFixed(2)}/s`;
            
            document.getElementById('buy-rot-button').textContent = `BUY ${rot.name} ($${rot.cost.toFixed(2)})`;
            
            const buyButton = document.getElementById('buy-rot-button');
            buyButton.disabled = money < rot.cost;
        }

        // --- GAME LOOP & ANIMATION (Physics and Rendering) ---

        function gameLoop() {
            money += incomePerSecond;
            updateHUD();
            
            const rot = BRAINROT_DATA[currentRotIndex];
            document.getElementById('buy-rot-button').disabled = money < rot.cost;
            
            if (isUpgradesVisible) {
                displayUpgrades();
            }
            if (isRebirthVisible) {
                updateRebirthMenu();
            }
        }

        const clock = new THREE.Clock();
        const color = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            cubeCamera.position.copy(player.position);
            cubeCamera.update(renderer, scene);
            
            const time = Date.now() * 0.001;

            adminBrainrotMeshes.forEach(mesh => {
                const r = (Math.sin(time * 2 + 0) + 1) / 2;
                const g = (Math.sin(time * 2 + 2) + 1) / 2;
                const b = (Math.sin(time * 2 + 4) + 1) / 2;
                color.setRGB(r, g, b);
                mesh.material.color.copy(color);
                mesh.rotation.y += delta * 2; 
            });
            
            if (!isSecretMenuVisible && currentModRotIndex === -1 && !isUpgradesVisible && !isDeleteMenuVisible && !isRebirthVisible) {
                
                playerVelocity.y += GRAVITY * delta;

                if (keys[' '] && isOnGround) {
                    playerVelocity.y = JUMP_FORCE;
                    isOnGround = false;
                    keys[' '] = false; 
                }

                const direction = new THREE.Vector3();
                if (keys.w) direction.z -= 1; 
                if (keys.s) direction.z += 1; 
                if (keys.a) direction.x -= 1; 
                if (keys.d) direction.x += 1; 
                
                playerVelocity.x = 0;
                playerVelocity.z = 0;

                if (direction.lengthSq() > 0) {
                    direction.normalize();
                    
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(player.rotation.y);
                    direction.applyMatrix4(rotationMatrix);

                    playerVelocity.x = direction.x * moveSpeed;
                    playerVelocity.z = direction.z * moveSpeed;
                } 

                player.position.x += playerVelocity.x * delta;
                player.position.z += playerVelocity.z * delta;
                player.position.y += playerVelocity.y * delta;

                if (player.position.y < playerHalfHeight) {
                    player.position.y = playerHalfHeight; 
                    playerVelocity.y = 0; 
                    isOnGround = true; 
                }
            } else {
                playerVelocity.set(0, 0, 0);
            }

            checkBrainrotPickup();

            renderer.render(scene, camera);
        }
        
        init();

    </script>
